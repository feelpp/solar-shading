<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Traversal Algorithms :: My Solar Shading</title>
    <link rel="canonical" href="https://feelpp.github.io/solar-shading/solar-shading/traversal.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../_/css/site.css">
<link rel="icon" href="../_/img/favicon.ico" type="image/x-icon">
<script>!function(l,p){if(l.protocol!==p&&l.host=="docs.antora.org"){l.protocol=p}else if(/\.gitlab\.io$/.test(l.host)){l.replace(p+"//docs.antora.org"+l.pathname.substr(l.pathname.indexOf("/",1))+l.search+l.hash)}}(location,"https:")</script>

<script src="../_/js/vendor/tabs-block-extension.js"></script>
<script src="../_/js/vendor/tabs-block-behavior.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },

  TeX: {
      Macros: {
      RR: "{\\mathbb R}",
      NN: "{\\mathbb N}",
      Nso: "{N_{\\mathrm{so}}}",
      Nma: "{N_{\\mathrm{ma}}}",
      Nno: "{N_{\\mathrm{no}}}",
      Ne: "{N_{\\mathrm{e}}}",
      Ilag: ["{\\mathcal{I}^{\\mathrm{lag}}_{#1}}",1],
      calTh: "{\\mathcal{T}_h}",
      Ck: ["{\\mathcal{C}^{#1}}",1],
      Pk: ["{\\mathcal{P}^{#1}}",1],
      Qk: ["{\\mathcal{Q}^{#1}}",1],
      Pch: ["{P^{#1}_{c,h}}",1],
      Pcho: ["{P^{#1}_{c,h,0}}",1],
      Qch: ["{Q^{#1}_{c,h}}",1],
      Ich: ["{\\mathcal{I}^{#1}_{c,h}#2}",2],
      poly: ["{\\mathbb{#1}}",1],
      nf: "{n_f}",
      ngeo: "{n_{\\mathrm{geo}}}",
      geo: "{\\mathrm{geo}}",
      card: ["{\\operatorname{card}(#1)}",1],
      dim: ["{\\operatorname{dim}(#1)}",1],
      opdim: "{\\operatorname{dim}}",
      card: ["{\\operatorname{card}(#1)}",1],
      poly: ["{\\mathbb{#1}",1],
      R: ["{\\mathbb{R}^{#1}}",1],
      set: ["{\\left\\{#1\\right\\}}",1],
      diam: "{\\operatorname{diam}}",
      jump: ["{[\\![ #1 ]\\!]}",1],
      Next: "{\\mathrm{n}}",
      essinf: "{\\operatorname{ess}\\, \\operatorname{inf}}",
      tr: "{\\operatorname{tr}}",
      Id: "{\\mathcal{I}}",
      disp: ["{\\mathbf{#1}}",1],
      stresst: ["{\\mathbf{\\sigma(#1)}}",1],
      deformt: ["{\\mathbf{\\varepsilon(#1)}}",1],
      domain: "{\\Omega}",
      prect: ["{\\left\\(#1\\right\\)}",1],
      ds: "",
      bold: ["{\\bf #1}",1],
      p: "{\\mathrm{p}}",
      q:"{\\mathbf{q}}",
      n:"{\\mathbf{n}}",
      T:"{\\mathcal{T}}",
      F:"{\\mathcal{F}}",
      P:"{\\mathcal{P}}",
      v:"{\\mathbf{v}}"
  },
  extensions: ["mhchem.js"] }
});
</script>
<!--<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<!-- <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML'>
</script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>-->

<!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js" integrity="sha384-jmxIlussZWB7qCuB+PgKG1uLjjxbVVIayPJwi6cG6Zb4YKq0JIw+OMnkkEC7kYCq" crossorigin="anonymous"></script>-->
<script>var uiRootPath = '../_'</script>

  </head>
  <body class="article">
<header class="header">
    <nav class="navbar navbar-expand-sm bg-dark navbar-dark navbar-template-project" style="border-top: 4px solid #9E9E9E">
        <div class="navbar-brand">
            <div class="navbar-item feelpp-logo">
                <a href="https://feelpp.github.io/solar-shading">My Solar Shading</a>
            </div>
            <button class="navbar-burger" data-target="topbar-nav">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>

        <div id="topbar-nav" class="navbar-menu">
            <div class="navbar-end">
                <div class="navbar-item">
                    <a href="https://docs.feelpp.org/">Documentation Reference</a>
                </div>
                <div class="navbar-item">
                    <a class="navbar-brand"  href="https://www.cemosis.fr">
                        <img class="cemosis-logo"  src="../_/img/cemosis-logo.svg" alt="Cemosis logo"/>
                    </a>
                </div>
            </div>
        </div>
    </nav>
</header>
<div class="body">
<div class="nav-container" data-component="solar-shading" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Feel++ Template Project</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="cmake.html">cmake environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="antora.html">antora environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="vscode.html">vscode integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="githubactions.html">Github Actions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="rename.html">Renaming the project</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jupyter.html">Jupyter Notebook</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="rapport.html">Rapport</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="rng.html">Random Number Generator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="bv.html">Bounding Volumes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="bvh.html">Bounding Volume Hierarchy</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="traversal.html">Traversal Algortihms</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="raytracing.html">Raytracing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="tools.html">Tools</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Feel++ Template Project</span>
    <span class="version">default</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="index.html">Feel++ Template Project</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">default</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
  <button class="nav-toggle"></button>
    <a href="index.html" class="home-link"></a>
  <nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Feel++ Template Project</a></li>
    <li><a href="rapport.html">Rapport</a></li>
    <li><a href="traversal.html">Traversal Algortihms</a></li>
  </ul>
</nav>

  
    <div class="edit-this-page"><a href="https://github.com/feelpp/solar-shading/edit/7-add-project-report-to-antora-pages/docs/modules/ROOT/pages/traversal.adoc">Edit this Page</a></div>
  
  <div class="page-downloads">
  <span class="label">Download as</span>
  <ul class="download-options">
    <li>
      <a onclick="print(this)" href="#" data-toggle="tooltip" data-placement="left" title="Print to PDF"
         class="pdf-download">
        <img class="pdf-file-icon icon" src="../_/img/pdf.svg"/> .pdf
      </a>
    </li>
  </ul>
</div>
</div>

  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>

<article class="doc">
<h1 class="page">Traversal Algorithms</h1>
<div class="sect1">
<h2 id="_stack_based_algorithms"><a class="anchor" href="#_stack_based_algorithms"></a>1. Stack-Based Algorithms</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_definition"><a class="anchor" href="#_definition"></a>1.1. Definition</h3>

</div>
<div class="sect2">
<h3 id="_algorithm"><a class="anchor" href="#_algorithm"></a>1.2. Algorithm</h3>

</div>
<div class="sect2">
<h3 id="_summary"><a class="anchor" href="#_summary"></a>1.3. Summary</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_stack_less_algorithms"><a class="anchor" href="#_stack_less_algorithms"></a>2. Stack-Less Algorithms</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_definition_2"><a class="anchor" href="#_definition_2"></a>2.1. Definition</h3>
<div class="paragraph">
<p>Traversing a ray through a bounding volume hierarchy is usually carried out in a recursive manner, therefore making it maintain a full stack per ray, which rapidly becomes very costly. Several stack-less algorithms exist, however they have to perform infrequent restarts of the traversal from the root or traverse more nodes than their stack-based counterparts.</p>
</div>
<div class="paragraph">
<p>Many reasons have pushed researches in this field, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>efficient memory usage:</strong> since stack-less algorithms don&#8217;t require keeping track of the traversal state. This is critical when implementing it on GPUs, where memory is very limited</p>
</li>
<li>
<p><strong>coherency:</strong> these algorithms can be more coherent in terms of memory access patterns, since they have more predictable behaviors</p>
</li>
<li>
<p><strong>predictability:</strong> predictable performance due lack of deep recursion possibilities, mostly occurring when applying a stack-based algorithm on a unbalanced BVH.</p>
</li>
<li>
<p><strong>parallelism:</strong> since they do not require to push and pop from a stack, these methods offer rich parallelization capabilities</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The presented algorithm presents a stack-less iterative method traversing the BVH structure in the exact same order as stack-based ones, mainly thanks to added parent-pointers stored within each node and thus performing only one ray-box intersection test per internal node.</p>
</div>
</div>
<div class="sect2">
<h3 id="_assumptions_to_be_made"><a class="anchor" href="#_assumptions_to_be_made"></a>2.2. Assumptions to be made</h3>
<div class="ulist">
<ul>
<li>
<p>use of a binary BVH, in which all primitives are stored in leaf nodes, and in which each inner node has exactly two children (so-called siblings)</p>
</li>
<li>
<p>there is an efficient way of determining each node&#8217;s parent and sibling</p>
</li>
<li>
<p>for each inner node there is a unique traversal order in which it&#8217;s children are traversed, possibly varying from ray to ray.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_algorithm_2"><a class="anchor" href="#_algorithm_2"></a>2.3. Algorithm</h3>
<div class="paragraph">
<p>A commonly-used way of storing the parent&#8217;s information is to store an explicit parent pointer for each node, done either by squeezing the parent pointer into unused parts of the node or by storing them directly in a separate array of parent pointers.</p>
</div>
<div class="paragraph">
<p>For traversal order, a first method would be to store for each node the coordinate axis along which the builder split the parent node and use the ray&#8217;s direction sign in this dimension to determine the traversal order. On the other hand, we can directly use the dimension in which the nodes' centroids are widest apart. Finally, we could also directly compute the distance to the sibling&#8217;s bounding boxes, inferring many computations.</p>
</div>
<div class="paragraph">
<p>First, in order to fully understand the methods benefits, let us understand all the underlyings of recursive algorithms. How does the traversal algorithm work?
After having successfully intersected the parent, the traversal goes to the <code>nearChild</code> (found with any type of method), and does a ray-box test for this node. If the node is missed, <code>farChild</code> is processed, But if the test was successful, it continues by intersecting its primitives (if the node is a leaf), or by recursively entering the node&#8217;s subtree (in case it&#8217;s an inner node). Once <code>nearChild</code> is fully processed, traversal resumes with <code>farChild</code> exactly and the same sequence of events takes place.</p>
</div>
<div class="paragraph">
<p>This already gives us an overlook of the simple deterministic automaton algorithm. In fact, we can start and make a parallel between the three ways of how any given node can be traversed and the tree states of the algorithm. During recursive traversal, a node can either be traversed:
- from its parents (case <code>fromParent</code>): we know that we are entering <code>nearChild</code>. We traverse the current node: if it&#8217;s missed, we proceed with a <code>fromSibling</code> case and if not, either it&#8217;s a leaf node and we intersect its primitives, or it&#8217;s an inner node and we continue with its subtree.
- from its siblings (case <code>fromSibling</code>): we are entering <code>farChild</code> and we are traversing this node for the first time. If it&#8217;s missed, we back-track to its parent. Otherwise we intersect it&#8217;s primitives against the ray if it&#8217;s a leaf node and proceed to parent, and if not we enter the current node&#8217;s subtree performing a <code>fromParent</code> step.
- from one of its children (case <code>fromChild</code>): the current node was already tested during the top to bottom phase, it <strong>should not</strong> be re-tested. The next on the list is either the current node&#8217;s <code>farChild</code> or its parent</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Algorithm Developed by the Authors</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void traverse(ray, node) {
	char state = fromParent;
	while (true) {
		switch (state) {
			case fromChild:
				if (current == root) return; // finished
				if (current == nearChild(parent(current))){
					current = sibling(current);
					state = fromSibling; // (1a)
				}
				else {
					current = parent(current);
					state = fromChild; // (1b)
				}
				break;
			case fromSibling:
				if (boxtest(ray, current) == MISSED) {
					current = parent(current);
					state = fromChild; // (2a)
					}
				else if (isLeaf(current)) {
					// ray-primite intersection tests
					processLeaf(ray, current);
					current = parent(current);
					state = fromChild; // (2b)
				}
				else {
					current = nearChild(current);
					state = fromParent; //2a
				}
				break;
			case fromParent:
				if (boxtest(ray, current) == MISSED) {
					current = sibling(current);
					state. = fromSibling; // (3a)
				}
				else if (isLeaf(current)) {
					// ray-primitive intersection tests
					processLeaf(current);
					current = sibling(current);
					state = fromSibling; // (3b)
				}
				else {
					current = nearChild(current);
					state = fromParent; // (3a)
				}
				break;
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/BVlayers.png" alt="BVlayers">
</div>
</div>
<div class="paragraph">
<p>And such spacial divisions can lead to a similar tree as the following:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/BVlayerstree.png" alt="BVlayerstree">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_stack_less_gpu_friendly_algorithm"><a class="anchor" href="#_stack_less_gpu_friendly_algorithm"></a>3. Stack-less GPU friendly Algorithm</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When looking ate the storage needed for the computation of ShadingMasks, we can pass the whole BVH structure and make a copy of it directly on the GPU&#8217;s shared memory. This way, we can avoid the need to transfer the BVH structure from the CPU to the GPU constantly, which can be a very expensive operation. Using such a method may cause problems depending on the size of the BVH structure, since the GPU&#8217;s shared memory is limited. However, we can use the BVH structure&#8217;s size as a parameter to determine whether or not we should use this method. If the BVH structure is too big, we can implement smaller structures to hold the BVH, preordering the nodes in flattened 1D array&#8217;s only containing useful information (and not all methods and attributes of the BVH structure). This way, we can reduce the size of the BVH structure and make it fit in the GPU&#8217;s shared memory. And since the traversal is performed <code>nRays * nElements</code> times (more than 5000 rays per element), we can compute the array&#8217;s once by indexing the nodes, its children and its parent.</p>
</div>
<div class="sect2">
<h3 id="_copy_by_value"><a class="anchor" href="#_copy_by_value"></a>3.1. Copy-by-value</h3>
<div class="paragraph">
<p>As presented on <a href="https://developer.nvidia.com/blog/thinking-parallel-part-ii-tree-traversal-gpu/">NVIDIA&#8217;s website</a>, we can directly create a copy of the wanted BVH structure, enabling it to be able to access all needed functions preceded with <code><em>device</em></code>. If the memory allows it we can use the state-based traversal algorithm presented above. NVIDIA&#8217;s website presents the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">__device__ void traverseIterative( CollisionList&amp; list,
                                   BVH&amp; bvh,
                                   AABB&amp; queryAABB,
                                   int queryObjectIdx)
{
    // Allocate traversal stack from thread-local memory,
    // and push NULL to indicate that there are no postponed nodes.
    NodePtr stack[64];
    NodePtr* stackPtr = stack;
    *stackPtr++ = NULL; // push

    // Traverse nodes starting from the root.
    NodePtr node = bvh.getRoot();
    do
    {
        // Check each child node for overlap.
        NodePtr childL = bvh.getLeftChild(node);
        NodePtr childR = bvh.getRightChild(node);
        bool overlapL = ( checkOverlap(queryAABB,
                                       bvh.getAABB(childL)) );
        bool overlapR = ( checkOverlap(queryAABB,
                                       bvh.getAABB(childR)) );

        // Query overlaps a leaf node =&gt; report collision.
        if (overlapL &amp;&amp; bvh.isLeaf(childL))
            list.add(queryObjectIdx, bvh.getObjectIdx(childL));

        if (overlapR &amp;&amp; bvh.isLeaf(childR))
            list.add(queryObjectIdx, bvh.getObjectIdx(childR));

        // Query overlaps an internal node =&gt; traverse.
        bool traverseL = (overlapL &amp;&amp; !bvh.isLeaf(childL));
        bool traverseR = (overlapR &amp;&amp; !bvh.isLeaf(childR));

        if (!traverseL &amp;&amp; !traverseR)
            node = *--stackPtr; // pop
        else
        {
            node = (traverseL) ? childL : childR;
            if (traverseL &amp;&amp; traverseR)
                *stackPtr++ = childR; // push
        }
    }
    while (node != NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But we will optimize it by using the state-based traversal algorithm presented above. Implementing it in CUDA will be similar, leveraging the complex BVH structure containing all the needed functions and attributes. We will also use the <code><em>device</em></code> keyword to make the functions accessible from the GPU.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preordering_algorithm"><a class="anchor" href="#_preordering_algorithm"></a>3.2. Preordering Algorithm</h3>
<div class="paragraph">
<p>If the memory is not big enough to store the whole BVH structure, we can use a preordering algorithm to store the BVH structure in a flattened 1D array. This way, we can store only the needed information for the traversal, and not the whole BVH structure. This method is presented in 'Real-Time Collision Detection' by Christer Ericson. The algorithm is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">int PreorderOutput(Tree *t, Tree n[], int i)
{
	// Implement a simple stack of parent nodes.
	// Note that the stack pointer ‘sp’ is automatically reset between calls
	const int STACK_SIZE = 100;
	static int parentStack[STACK_SIZE];
	static int sp = 0;
	// Copy over contents from tree node to PTO tree
	n[i].nodeData = t-&gt;nodeData;
	// Set the flag indicating whether there is a left child
	n[i].hasLeft = t-&gt;left != NULL;
	// If node has right child, push its index for backpatching
	if (t-&gt;right) {
		assert(sp &lt; STACK_SIZE);
		parentStack[sp++] = i;
	}
	// Now recurse over left part of tree
	if (t-&gt;left)
		i = PreorderOutput(t-&gt;left, n, i + 1);
	if (t-&gt;right) {
		// Backpatch right-link of parent to point to this node
		int p = parentStack[--sp];
		n[p].rightPtr = &amp;n[i + 1];
		// Recurse over right part of tree
		i = PreorderOutput(t-&gt;right, n, i + 1);
	}
	// Return the updated array index on exit
	return i;
}

struct Tree {
	NodeData nodeData;
	bool hasLeft;
	Tree *rightPtr;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A stack is only used once, in order to identify the order of traversal, but will never be used on GPUs.</p>
</div>
<div class="paragraph">
<p>This representation also leverages the use of pointers, only using one to point to the right child, which would be accessed only later during traversal since we use a <code>depth-first</code> search if the intersection test was successful for a given node.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>4. Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When dealing with the computation of shading masks, view factors or radiative transport, we use static geometry to realistically represent the scene. Only few topological changes have to be taken into account, hence the decision of also optimizing the build for the BVH tree&#8217;s quality in order to reduce traversal operations. Even if the construction speed is important, we are not developing a real-time application, but rather trying to compute physically realistic results. We can build the BVH once and reuse it for multiple ray tracing operations without the need to update or rebuild the BVH. This approach can significantly improve performance, as constructing the BVH is a computationally expensive operation.</p>
</div>
<div class="paragraph">
<p>Even when taking into account the changes occurring due to the seasonality of the chosen districts and cities (french cities are subdued to changing weather conditions, leaves are falling and trees do not cast as big of a shadow in winter than in summer).</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer" style="border-top: 2px solid #e9e9e9; background-color: #fafafa; padding-bottom: 2em; padding-top: 2em;">
    <div class="container" style="display: flex; flex-direction: column; align-items: center; gap: 0.5em;">
        <div>
            <a href="https://www.cemosis.fr">
                <img src="../_/img/cemosis-logo.svg" alt="Cemosis logo" height="50">
            </a>
        </div>
        <span style="font-size: 0.8rem; color: #9e9e9e">© 2023 <a href="https://www.cemosis.fr" style="text-decoration: underline;">Cemosis</a>, Université de Strasbourg</span>
    </div>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>


<script async src="../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../_/js/vendor/fontawesome.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>


<script type="text/javascript">
function toggleFullScreen() {
   var doc = window.document;
   var docEl = doc.documentElement;

   var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
   var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

   if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
       requestFullScreen.call(docEl);
   }
   else {
       cancelFullScreen.call(doc);
   }
}
</script>
  </body>
</html>
